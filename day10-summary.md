# DAY10
# 알고리즘
#### 알고리즘이란?
문제 해결을 위한 일련의 절차나 방법
# 자료구조(Data Structure)
#### 자료구조란?
자료를 효율적으로 이용할 수 있는 방법론

**왜 자료구조가 필요할까?**
자원이 한정적이니까...  
방대한 양의 데이터를 DB라는 시스템에 의해 보조기억장치에 저장되어 있을 텐데..  
CPU에 의해 main memory에다 유의미한, 원하는 정보들만 불러들인다.  
따라서, main memory 사이즈가 한정적이므로, 어떻게 한정적인 주기억장치를 효율적으로 쓸 것이냐, 어떻게 자료를 효율적으로 주기억장치에 배치할 것이냐가 자료구조와 알고리즘의 핵심.  

#### 자료 구조 종류
1. **배열**
	- 배열 항목의 추가, 삭제가 어렵다.  
	- 배열 공간이 가변적이지 못하다.  
	- 인덱싱이 용이하다.(배열 공간이 물리적으로 이어져 있으므로)

배열의 단점을 극복하기 위한 방법?
```
	linked list  
```

2. **연결 리스트**
```
배열에 비해 추가 정보가 필요하므로, 데이타를 더 소모.(앞뒤 리스트들과의 연결 정보가 필요함).  
인덱스가 용이하지 못함.(리스트들은 메모리에 각각 떨어져서 저장되어 있으므로)   
항목의 추가, 삭제가 배열보다 용이함.  
```
##### 리스트의 종류
1. 단순 연결 리스트
2. 이중 연결
3. 원형 연결

```
실질적으로는 리스트의 단점인 비효율적인 인덱싱(성능 저하)은 cpu의 고성능으로 성능 극복이 되어, 개발자들은 리스트의 장점을 가지고 배열보단 리스트로 코딩을 한다.
```

3. **Stack**  
	- push : 데이터 넣기  
	- pop : 데이타 꺼내기  

4. **Queue**  
먼저 온 것(pu or enqueue)이 먼저 나가는(get, dequeue) 구조  

5. **Dequeue(덱))**  
Double Ended Queue(stack + queue)  

사설 : 컴퓨터 용어나 개념들은 무조건 잡식해라(by 야곰 조성규)  
면접땐 자신이 자신있는 분야로 유도 할 수 있게 대답..  
그러면 면접관들은 그 쪽으로 면접 질문을 할 것임.  

6. **Tree**  
이 구조가 왜 필요할까? 배열이나 리스트와는 뭐가 다른가?  
	1. 가계도 같은 hierachy를 도식화할 수 있다.  
	2. 탐색이 용이하게 구조화한 것이 Tree이다.(배열, 리스트는 순차적으로 탐색함)  
	3. 부모 자식간의 상관관계가 있다. 자식은  하나의 부모만 가질 수 있다.   
	4. 시작점과 끝점을 알 수 있다.  

7. **Graph**  
이 구조가 왜 필요할까?  
	- 예) Navi의 최단 거리 구하기.  SNS(페북 그래프: 페북 친구), 구매 패턴 분석 등.  

단, 시작점과 끝점을 알 수 없다.  

#### 알고리즘
일을 처리하는 순서/방법  
대표적인 예: 정렬, 탐색, 재귀   
```
이런 알고리즘들은 이렇게 하면 보다 효율적이다는 의미이지. 이것만이 정답은 아니다.   
정답은 무궁무진하다. 이러한 알고리즘이 공식화되어 쓰이는 것이 정답이 아니다.  
지속적인 연습과 생각/고민, 기존 효율적인 알고리즘들을 나의 목적에 맞게 변형을 시키는 연습.  
이러한 것들이 알고리즘을 배우는 목적이라 생각한다. (by 야곰 조성규)     
```

참고) 정렬 알고리즘 비교 영상  

#### 알고리즘의 종류
1. 선택(Selection sort)  
	-	전 구간에서 제일 작은 값을 찾아서 오름차순으로 왼쪽부터 정렬.  
2. 버블 정렬(Bubble sort)  
	- 두 개씩 순차적으로 비교하여 큰 놈을 뒤로 보냄. 제일 큰 놈을 맨 오른쪽으로 보냄.  
3. 삽입 정렬
  - 자기보다 바로 작은 값과 바로 큰 값 사이에 자기를 삽입한다.
	- 자기보다 작은 값을 만나면 바로 멈추고 삽입. 그러면 바로 뒤는 자기보다 바로 큰 값이겠지.  
4. 병합 정렬(Merge sort)
	- 작은 단위로 정렬을 해놓은 것들을 병합(merge)한다.
5. 퀵 정렬(quick sort)
	- 기준 값을 기준으로 기준보다 작으면 왼쪽, 크면 오른쪽으로 보냄.  
	- 기준 점을 잡는 것이 key-point. 중간 값을 잘 찾아야 하는데, 너무 치우친 값(너무 작거나 큰 값)을 기준 값으로 잡으면 비효율적인 sorting이 되기 떄문이다.   
	-	왜 퀵일까? 어떤 조건에서도 평균적인 성능을 보임.  

알고리즘이라는 것은 정답이 없다.
가령, 자료가 어떤 형태로 저장되어 있고, 분포되어 있는지, 그리고, 시스템에 적합한, 성능을 더 중요시 하느냐에 따라 적용 알고리즘도 달라진다.

**시간 복잡도(O) : 점근 표기법**
	- 알고리즘이 실행되는 데 소요되는 시간 분석
	- Big O 표기법이라고 함.
	- 자료가 최악의 조건으로 배치되어 있다는 조건하에서.
	- 1,2,3 : O(n^2)의 시간 복잡도
	- 병합/퀵 정렬은 빠름 : O(nlog n)
	- __서버쪽에선 알고리즘이 중요하다__.

**탐색 알고리즘의 시간 복잡도**
	- 선형 탐색 : O(n)
	- 이진 탐색 : O(log n) 한 단계씩 내려갈 때마다 1/2씩은 떨어져 나감.
		(1/2씩은 검색을 할 필요가 없으므로) (1/2)^k

**탐색 알고리즘의 공간 복잡도**
	- 공간 복잡도와 시간 복잡도는 서로 배타적인 관계이므로,
	- 실제 환경(서버 환경)에 맞게, 목적에 맞게 알고리즘을 구현해야 한다.

사설 : 알고리즘을 구현할 때는 미리 연습장에 그려보고 나서, 코드 연습해보기. 굳이 머리로만 코딩을 하려 하지 말것.

**자료 구조**  
배열, 연결리스트 스택, 큐, 트리, 그래프
